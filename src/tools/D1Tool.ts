/**
 * @file D1Tool.ts
 * @description Provides a robust, type-safe interface for interacting with Cloudflare D1 databases.
 * This tool is designed for AI agents to perform database operations. It ensures that all
 * queries are parameterized to prevent SQL injection vulnerabilities, a critical security
 * consideration when executing commands generated by an AI.
 */

import { D1Database, D1Result } from '@cloudflare/workers-types';

interface Env {
    [key: string]: D1Database;
}

export class D1Tool {
    private env: Env;

    /**
     * @description Initializes the D1Tool with the worker's environment.
     * @param {Env} env - The Cloudflare worker environment containing D1 bindings.
     */
    constructor(env: Env) {
        this.env = env;
    }

    /**
     * @description Retrieves a D1 database binding from the environment.
     * Throws an error if the specified binding name is not found.
     * @param {string} database_binding - The name of the D1 binding in wrangler.toml.
     * @returns {D1Database} The D1 database instance.
     * @private
     */
    private getDb(database_binding: string): D1Database {
        const db = this.env[database_binding];
        if (!db) {
            throw new Error(`D1 database binding '${database_binding}' not found.`);
        }
        return db;
    }

    /**
     * @description Executes a SQL query against the specified D1 database using parameterized statements
     * to prevent SQL injection. This is the primary method for safe data retrieval.
     * @param {string} database_binding - The name of the D1 binding.
     * @param {string} sql - The SQL query string with '?' placeholders for parameters.
     * @param {any[]} [params] - An array of parameters to bind to the SQL query.
     * @returns {Promise<D1Result>} A promise that resolves with the query results.
     */
    async query(database_binding: string, sql: string, params: any[] = []): Promise<D1Result> {
        try {
            const db = this.getDb(database_binding);
            const stmt = db.prepare(sql).bind(...params);
            return await stmt.all();
        } catch (error) {
            console.error(`D1Tool query failed for binding '${database_binding}':`, error);
            throw new Error(`D1 query failed: ${error.message}`);
        }
    }

    /**
     * @description Inserts a record into the specified table. Column names are automatically
     * derived from the provided data object and the values are bound safely using
     * parameterised statements.
     */
    async insert(database_binding: string, table: string, data: Record<string, any>): Promise<D1Result> {
        const columns = Object.keys(data);
        const placeholders = columns.map(() => '?').join(', ');
        const sql = `INSERT INTO ${table} (${columns.join(', ')}) VALUES (${placeholders})`;
        const values = columns.map(column => data[column]);
        return this.query(database_binding, sql, values);
    }

    /**
     * @description Performs a partial update on a row identified by its primary key.
     */
    async update(database_binding: string, table: string, idColumn: string, id: string, data: Record<string, any>): Promise<D1Result> {
        const columns = Object.keys(data);
        const assignments = columns.map(column => `${column} = ?`).join(', ');
        const sql = `UPDATE ${table} SET ${assignments} WHERE ${idColumn} = ?`;
        const values = [...columns.map(column => data[column]), id];
        return this.query(database_binding, sql, values);
    }

    /**
     * @description Convenience helper for retrieving a list of rows.
     */
    async list(database_binding: string, table: string, limit: number = 50): Promise<any[]> {
        const sql = `SELECT * FROM ${table} ORDER BY created_at DESC LIMIT ?`;
        const { results } = await this.query(database_binding, sql, [limit]);
        return results ?? [];
    }

    /**
     * @description Retrieves a single row by ID.
     */
    async getById(database_binding: string, table: string, idColumn: string, id: string): Promise<any | null> {
        const sql = `SELECT * FROM ${table} WHERE ${idColumn} = ? LIMIT 1`;
        const { results } = await this.query(database_binding, sql, [id]);
        return results && results.length > 0 ? results[0] : null;
    }

    /**
     * @description Applies the initial database schema. This is a powerful, one-time operation.
     * @param {string} database_binding - The name of the D1 binding.
     * @returns {Promise<any>} The result of the batch operation.
     */
    async init_schema(database_binding: string): Promise<any> {
        const db = this.getDb(database_binding);
        const schema = `
            CREATE TABLE best_practices ( id TEXT PRIMARY KEY, topic TEXT NOT NULL, guidance TEXT NOT NULL, source TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP );
            CREATE TABLE development_projects ( id TEXT PRIMARY KEY, name TEXT NOT NULL, description TEXT, github_url TEXT, status TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP );
            CREATE TABLE development_project_plans ( id TEXT PRIMARY KEY, project_id TEXT NOT NULL, plan TEXT NOT NULL, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (project_id) REFERENCES development_projects(id) );
            CREATE TABLE development_consultations ( id TEXT PRIMARY KEY, project_id TEXT NOT NULL, question TEXT NOT NULL, context TEXT, agent_response TEXT, status TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (project_id) REFERENCES development_projects(id) );
            CREATE TABLE error_consultations ( id TEXT PRIMARY KEY, error_message TEXT NOT NULL, stack_trace TEXT, code_snippet TEXT, analysis TEXT, suggested_fix TEXT, status TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP );
            CREATE TABLE research_briefs ( id TEXT PRIMARY KEY, topic TEXT NOT NULL, summary TEXT, status TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP );
            CREATE TABLE research_repos_reviewed ( id TEXT PRIMARY KEY, brief_id TEXT NOT NULL, repo_url TEXT NOT NULL, review_notes TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (brief_id) REFERENCES research_briefs(id) );
            CREATE TABLE research_findings ( id TEXT PRIMARY KEY, brief_id TEXT NOT NULL, finding TEXT NOT NULL, source_repo_id TEXT, source_file_path TEXT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP, FOREIGN KEY (brief_id) REFERENCES research_briefs(id), FOREIGN KEY (source_repo_id) REFERENCES research_repos_reviewed(id) );
        `;
        const statements = schema.trim().split(';').filter(s => s.trim().length > 0).map(s => db.prepare(s));
        return await db.batch(statements);
    }
}